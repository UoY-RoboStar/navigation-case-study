#!/usr/bin/env python3
"""
TurtleBot 3 Waypoint Navigator - Navigation2 Implementation

This ROS 2 node navigates TurtleBot 3 through a sequence of waypoints
using the Navigation2 stack's NavigateToPose action server.

Features:
- Autonomous path planning with obstacle avoidance
- AMCL-based localization
- Repeating waypoint sequences
- Multi-robot support via namespaces
- Comprehensive logging and statistics

Usage:
    ros2 run turtlebot3_waypoint_navigator waypoint_navigator_nav2

    With options:
    ros2 run turtlebot3_waypoint_navigator waypoint_navigator_nav2 \
        --ros-args -p max_loops:=5 -p pause_at_waypoint:=2.0
"""

import math
import time
from typing import List, Tuple

import rclpy
from geometry_msgs.msg import Point, Pose, PoseStamped, PoseWithCovarianceStamped, Quaternion
from nav2_msgs.action import NavigateToPose
from rclpy.action import ActionClient
from rclpy.executors import MultiThreadedExecutor
from rclpy.node import Node
# Using manual quaternion conversion instead of tf_transformations


class TurtleBot3WaypointNavigatorNav2(Node):
    """ROS 2 Node for TurtleBot 3 waypoint navigation using Navigation2 stack."""

    def __init__(self):
        super().__init__('turtlebot3_waypoint_navigator_nav2')

        # Declare parameters
        self.declare_parameter('max_loops', 0)  # 0 = infinite
        self.declare_parameter('pause_at_waypoint', 1.0)
        self.declare_parameter('namespace', '')

        # Get parameters
        self.max_loops = self.get_parameter('max_loops').value
        self.pause_at_waypoint = self.get_parameter('pause_at_waypoint').value
        self.namespace = self.get_parameter('namespace').value

                # Define waypoints for turtlebot3_world - safe perimeter path
        self.waypoints = [
            {"x": -2.2, "y": -0.5, "theta": math.pi, "name": "Start West"},
            {"x": -2.2, "y": -2.2, "theta": -math.pi/2, "name": "Southwest Far"},
            {"x": -2.0, "y": -2.2, "theta": 0.0, "name": "Southwest"},
            {"x": -1.0, "y": -2.2, "theta": 0.0, "name": "South 1"},
            {"x": 0.0, "y": -2.2, "theta": 0.0, "name": "South Center"},
            {"x": 1.0, "y": -2.2, "theta": 0.0, "name": "South 2"},
            {"x": 2.0, "y": -2.2, "theta": math.pi/2, "name": "Southeast"},
            {"x": 2.0, "y": -1.0, "theta": math.pi/2, "name": "East 1"},
            {"x": 2.0, "y": 0.0, "theta": math.pi/2, "name": "East Center"},
            {"x": 2.0, "y": 1.0, "theta": math.pi/2, "name": "East 2"},
            {"x": 2.0, "y": 2.2, "theta": math.pi, "name": "Northeast"},
            {"x": 1.0, "y": 2.2, "theta": math.pi, "name": "North 1"},
            {"x": 0.0, "y": 2.2, "theta": math.pi, "name": "North Center"},
            {"x": -1.0, "y": 2.2, "theta": math.pi, "name": "North 2"},
            {"x": -2.0, "y": 2.2, "theta": -math.pi/2, "name": "Northwest"},
            {"x": -2.0, "y": 1.0, "theta": -math.pi/2, "name": "West 1"},
            {"x": -2.0, "y": 0.0, "theta": -math.pi/2, "name": "West Center"},
            {"x": -2.0, "y": -0.5, "theta": -math.pi/2, "name": "Return to Start"},
        ]

        # Initialize action client for Navigation2
        self.nav_to_pose_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')

        # Publisher for initial pose (for AMCL localization)
        self.initial_pose_pub = self.create_publisher(
            PoseWithCovarianceStamped, 
            '/initialpose', 
            10
        )

        # Subscriber for AMCL pose to verify localization
        self.amcl_pose_received = False
        self.latest_amcl_pose = None
        self.amcl_pose_sub = self.create_subscription(
            PoseWithCovarianceStamped,
            '/amcl_pose',
            self.amcl_pose_callback,
            10
        )

        # State tracking
        self.current_waypoint_index = 0
        self.loop_count = 0
        self.goal_handle = None

        self.get_logger().info(f'TurtleBot 3 Waypoint Navigator (Nav2) initialized')
        self.get_logger().info(f'Loaded {len(self.waypoints)} waypoints')
        self.get_logger().info(f'Max loops: {self.max_loops if self.max_loops > 0 else "infinite"}')
        self.get_logger().info(f'Pause at waypoint: {self.pause_at_waypoint}s')

        # Wait for nav2 server
        self._wait_for_nav2_server()
    def set_initial_pose(self, x: float = -2.0, y: float = -0.5, theta: float = 0.0) -> None:
        """Set the initial pose for AMCL localization.
        
        Args:
            x: Initial x position (default: spawn position)
            y: Initial y position (default: spawn position)
            theta: Initial orientation in radians (default: 0.0)
        """
        self.get_logger().info(f'Setting initial pose: ({x:.2f}, {y:.2f}, {theta:.2f} rad)')
        
        initial_pose = PoseWithCovarianceStamped()
        initial_pose.header.frame_id = 'map'
        initial_pose.header.stamp = self.get_clock().now().to_msg()
        
        # Set position
        initial_pose.pose.pose.position.x = x
        initial_pose.pose.pose.position.y = y
        initial_pose.pose.pose.position.z = 0.0
        
        # Set orientation (quaternion from yaw)
        quaternion = self.quaternion_from_euler(0, 0, theta)
        initial_pose.pose.pose.orientation.x = quaternion[0]
        initial_pose.pose.pose.orientation.y = quaternion[1]
        initial_pose.pose.pose.orientation.z = quaternion[2]
        initial_pose.pose.pose.orientation.w = quaternion[3]
        
        # Set covariance (uncertainty in the initial pose)
        # Diagonal values: x, y, z, rotation about X, Y, Z (36 values total)
        initial_pose.pose.covariance = [
            0.25, 0.0, 0.0, 0.0, 0.0, 0.0,  # x variance
            0.0, 0.25, 0.0, 0.0, 0.0, 0.0,  # y variance
            0.0, 0.0, 0.0, 0.0, 0.0, 0.0,   # z variance (not used)
            0.0, 0.0, 0.0, 0.0, 0.0, 0.0,   # rotation about x (not used)
            0.0, 0.0, 0.0, 0.0, 0.0, 0.0,   # rotation about y (not used)
            0.0, 0.0, 0.0, 0.0, 0.0, 0.07,  # yaw variance
        ]
        
        # Publish the initial pose (publish multiple times to ensure it's received)
        for i in range(10):
            self.initial_pose_pub.publish(initial_pose)
            time.sleep(0.1)
        
        self.get_logger().info('Initial pose published to AMCL')



    def _wait_for_nav2_server(self) -> None:
        """Wait for Navigation2 action server to become available."""
        self.get_logger().info('Waiting for NavigateToPose action server...')
        while not self.nav_to_pose_client.wait_for_server(timeout_sec=1.0):
            self.get_logger().info('Still waiting for NavigateToPose action server...')
            if not rclpy.ok():
                return

        self.get_logger().info('NavigateToPose action server is available!')

    def amcl_pose_callback(self, msg: PoseWithCovarianceStamped) -> None:
        """Callback when AMCL publishes pose estimate."""
        if not self.amcl_pose_received:
            self.get_logger().info(
                f'AMCL pose received: '
                f'({msg.pose.pose.position.x:.2f}, {msg.pose.pose.position.y:.2f})'
            )
        self.amcl_pose_received = True
        self.latest_amcl_pose = msg

    @staticmethod
    def quaternion_from_euler(roll, pitch, yaw):
        """Convert Euler angles to quaternion (roll, pitch, yaw in radians)."""
        import math
        cy = math.cos(yaw * 0.5)
        sy = math.sin(yaw * 0.5)
        cp = math.cos(pitch * 0.5)
        sp = math.sin(pitch * 0.5)
        cr = math.cos(roll * 0.5)
        sr = math.sin(roll * 0.5)

        qw = cr * cp * cy + sr * sp * sy
        qx = sr * cp * cy - cr * sp * sy
        qy = cr * sp * cy + sr * cp * sy
        qz = cr * cp * sy - sr * sp * cy

        return [qx, qy, qz, qw]



    def create_pose_stamped(self, waypoint: dict) -> PoseStamped:
        """Create a PoseStamped message from waypoint coordinates."""
        pose = PoseStamped()
        pose.header.frame_id = 'map'
        pose.header.stamp = self.get_clock().now().to_msg()

        # Set position
        pose.pose.position = Point(x=float(waypoint['x']), y=float(waypoint['y']), z=0.0)

        # Convert theta to quaternion
        quaternion = self.quaternion_from_euler(0, 0, float(waypoint['theta']))
        pose.pose.orientation = Quaternion(
            x=quaternion[0],
            y=quaternion[1],
            z=quaternion[2],
            w=quaternion[3]
        )

        return pose

    def navigate_to_waypoint(self, waypoint_index: int) -> None:
        """Send a goal to navigate to the specified waypoint."""
        if waypoint_index >= len(self.waypoints):
            self.get_logger().error(f'Invalid waypoint index: {waypoint_index}')
            return

        waypoint = self.waypoints[waypoint_index]
        self.get_logger().info(
            f'[Loop {self.loop_count}] Navigating to {waypoint["name"]} '
            f'({waypoint["x"]:.2f}, {waypoint["y"]:.2f})'
        )

        # Create and send the goal
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = self.create_pose_stamped(waypoint)

        # Send the goal asynchronously
        send_goal_future = self.nav_to_pose_client.send_goal_async(goal_msg)
        send_goal_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future) -> None:
        """Callback for when goal is accepted or rejected."""
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().warn('Goal was rejected by the action server')
            self.proceed_to_next_waypoint()
            return

        self.goal_handle = goal_handle
        self.get_logger().info('Goal accepted by the action server')

        # Get the result asynchronously
        get_result_future = goal_handle.get_result_async()
        get_result_future.add_done_callback(self.goal_result_callback)

    def goal_result_callback(self, future) -> None:
        """Callback for when navigation goal result is received."""
        result = future.result().result
        status = future.result().status

        if status == 4:  # SUCCEEDED
            self.get_logger().info('Goal succeeded!')
        else:
            self.get_logger().warn(f'Goal failed with status: {status}')

        self.proceed_to_next_waypoint()

    def proceed_to_next_waypoint(self) -> None:
        """Move to the next waypoint in the sequence."""
        # Pause at current waypoint
        self.get_logger().info(f'Pausing at waypoint for {self.pause_at_waypoint}s')
        time.sleep(self.pause_at_waypoint)

        # Update waypoint index
        self.current_waypoint_index += 1

        # Check if we've completed a full loop
        if self.current_waypoint_index >= len(self.waypoints):
            self.current_waypoint_index = 0
            self.loop_count += 1
            self.get_logger().info(
                f'Completed loop {self.loop_count}. '
                f'Total waypoints traversed: {self.loop_count * len(self.waypoints)}'
            )

            # Check if we should stop
            if self.max_loops > 0 and self.loop_count >= self.max_loops:
                self.get_logger().info(f'Reached maximum loops ({self.max_loops}). Stopping.')
                return

        # Navigate to next waypoint
        self.navigate_to_waypoint(self.current_waypoint_index)

    def start_navigation(self) -> None:
        """Start the waypoint navigation sequence."""
        self.get_logger().info('Starting waypoint navigation...')

        # Set initial pose for AMCL localization (robot spawn position)
        self.set_initial_pose(x=-2.0, y=-0.5, theta=0.0)

        # Wait for AMCL to converge
        self.get_logger().info('Waiting for AMCL to converge...')
        timeout = 30.0  # 30 second timeout
        start_time = time.time()
        wait_count = 0

        # Actively wait for AMCL pose
        while not self.amcl_pose_received and (time.time() - start_time) < timeout:
            rclpy.spin_once(self, timeout_sec=0.1)
            wait_count += 1
            if wait_count % 10 == 0:  # Log every second
                elapsed = time.time() - start_time
                self.get_logger().info(f'Still waiting for AMCL... ({elapsed:.1f}s elapsed)')

        if not self.amcl_pose_received:
            self.get_logger().error(
                'AMCL did not publish pose within timeout! '
                'Navigation may fail. Check if AMCL is running and map is loaded.'
            )
            # Continue anyway, but warn user
            self.get_logger().info('Waiting 10 more seconds before attempting navigation...')
            time.sleep(10.0)
        else:
            self.get_logger().info(
                f'AMCL converged successfully! '
                f'Robot localized at ({self.latest_amcl_pose.pose.pose.position.x:.2f}, '
                f'{self.latest_amcl_pose.pose.pose.position.y:.2f})'
            )
            # Additional wait for stability
            self.get_logger().info('Waiting 3 more seconds for particle filter to stabilize...')
            time.sleep(3.0)

        self.get_logger().info('Starting navigation to first waypoint...')
        self.navigate_to_waypoint(0)

    def stop_navigation(self) -> None:
        """Stop the current navigation goal."""
        if self.goal_handle:
            self.goal_handle.cancel_goal_async()
            self.get_logger().info('Navigation cancelled')


def main(args=None):
    """Main entry point for the waypoint navigator node."""
    rclpy.init(args=args)

    navigator = TurtleBot3WaypointNavigatorNav2()

    # Create a multi-threaded executor to handle callbacks
    executor = MultiThreadedExecutor(num_threads=4)
    executor.add_node(navigator)

    try:
        # Start navigation
        navigator.start_navigation()

        # Spin the executor to process callbacks
        executor.spin()

    except KeyboardInterrupt:
        navigator.get_logger().info('Shutting down...')
        navigator.stop_navigation()
    finally:
        rclpy.shutdown()


if __name__ == '__main__':
    main()
