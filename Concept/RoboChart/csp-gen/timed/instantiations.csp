-- generate sequence_functions_hasMaxReal
sequence_functions_hasMaxReal(a) = true

-- generate const_Adaptation_Analyse_Adaptation_Analyse_replanningSensitivity
const_Adaptation_Analyse_Adaptation_Analyse_replanningSensitivity = 0

-- generate string
nametype core_string = LSeq(Char,2)

-- generate sequence_functions_zipSeqs
sequence_functions_zipSeqs(seq1,seq2) = <>

-- generate const_Adaptation_Analyse_Adaptation_Analyse_occlusionSensitivity
const_Adaptation_Analyse_Adaptation_Analyse_occlusionSensitivity = 0

-- generate -- OPERATION BOUNDS

-- MODULE CONSTANTS

-- CONTROLLER CONSTANTS

-- STATEMACHINE CONSTANTS

-- OPERATION CONSTANTS

-- BASIC TYPES

-- generate sequence_functions_rotateSeq
sequence_functions_rotateSeq(s,n) = <>

-- generate const_Adaptation_Adaptation_stm_ref1_slidingWindowSize
const_Adaptation_Adaptation_stm_ref1_slidingWindowSize = 0

-- generate const_Adaptation_Adaptation_stm_ref1_replanningSensitivity
const_Adaptation_Adaptation_stm_ref1_replanningSensitivity = 0

-- OPERATION CONSTANTS

-- BASIC TYPES

-- generate sequence_functions_foldSeq
sequence_functions_foldSeq(f,seq,init) = 0

-- generate sequence_functions_rangeStep
sequence_functions_rangeStep(x,y,step) = <>

-- generate Plus
Plus(e1,e2,T) = if member(e1+e2,T) then e1+e2 else e1

-- generate sequence_functions_hasMinReal
sequence_functions_hasMinReal(a) = true

-- generate --

-- MODULE CONSTANTS

-- CONTROLLER CONSTANTS

-- STATEMACHINE CONSTANTS

-- generate nat
nametype core_nat = union({0..2},{calc_type_min(Union(
			{{1},{0..2},{0..2},Object,{0..2},{0..2},{0},{sequence_toolkit_head(seq)|seq <- LSeq(Object,2)},{1},{1},{sequence_toolkit_head(seq)|seq <- LSeq(Object,2)},{},{strengthenForward},{0},{weakenBackward},{1},{0},{init|init <- Object},{0},{weakenForward},{0}}))..calc_type_max(Union({{1},{0..2},{0..2},Object,{0..2},{0..2},{0},{sequence_toolkit_head(seq)|seq <- LSeq(Object,2)},{1},{1},{sequence_toolkit_head(seq)|seq <- LSeq(Object,2)},{},{strengthenForward},{0},{weakenBackward},{1},{0},{init|init <- Object},{0},{weakenForward},{0}}))})

-- generate core_clock_type
nametype core_clock_type = {0..10}

-- BASIC FUNCTIONS

-- generate sequence_functions_round
sequence_functions_round(x) = 0

-- generate const_Adaptation_Plan_Adaptation_Plan_PI
const_Adaptation_Plan_Adaptation_Plan_PI = 0

-- generate const_Adaptation_Adaptation_stm_ref2_PI
const_Adaptation_Adaptation_stm_ref2_PI = 0

-- generate const_Adaptation_Analyse_Adaptation_Analyse_occlusionThreshold
const_Adaptation_Analyse_Adaptation_Analyse_occlusionThreshold = 0

-- generate const_Adaptation_Analyse_Adaptation_Analyse_slidingWindowSize
const_Adaptation_Analyse_Adaptation_Analyse_slidingWindowSize = 0

-- generate sequence_functions_minReal
sequence_functions_minReal(a) = 0

-- generate const_Adaptation_Adaptation_stm_ref1_occlusionSensitivity
const_Adaptation_Adaptation_stm_ref1_occlusionSensitivity = 0

-- generate real
nametype core_real = union({ -2..2},{calc_type_min(Union(
			{{1},{0..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{0..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},Object,{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{0..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{0..2},{Types_BoolLidarMask_baseAngle(plannedLidarMask_var)|plannedLidarMask_var <- {(f_values,f_baseAngle)|f_values <- LSeq(core_boolean,2),f_baseAngle <- { -2..2}}},{sequence_toolkit_head(seq)|seq <- LSeq(Object,2)},{Div((Mult(omega, duration, { -2..2})), no_zero_div(baseAngle), { -2..2})},{1},{Neg(1, core_int)},{numRotations},{},{strengthenForward},{0},{numRotations},{weakenBackward},{Neg(1, core_int)},{n|n <- { -2..2}},{weakenForward},{0},{0},{1},{Div(occlusionSensitivity, no_zero_div(Types_BoolLidarMask_baseAngle(lidarMask)), { -2..2})|occlusionSensitivity <- { -2..2},lidarMask <- {(f_values,f_baseAngle)|f_values <- LSeq(core_boolean,2),f_baseAngle <- { -2..2}}},{sequence_toolkit_head(seq)|seq <- LSeq(Object,2)},{Types_BoolLidarMask_baseAngle(plannedLidarMask_var)|plannedLidarMask_var <- {(f_values,f_baseAngle)|f_values <- LSeq(core_boolean,2),f_baseAngle <- { -2..2}}},{n|n <- { -2..2}},{1},{0},{init|init <- Object},{Minus(n, 1, core_int)|n <- { -2..2}},{rotationAmount},{0},{Plus(n, 1, core_int)|n <- { -2..2}}}))..calc_type_max(Union({{1},{0..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{0..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},Object,{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{0..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{ -2..2},{0..2},{Types_BoolLidarMask_baseAngle(plannedLidarMask_var)|plannedLidarMask_var <- {(f_values,f_baseAngle)|f_values <- LSeq(core_boolean,2),f_baseAngle <- { -2..2}}},{sequence_toolkit_head(seq)|seq <- LSeq(Object,2)},{Div((Mult(omega, duration, { -2..2})), no_zero_div(baseAngle), { -2..2})},{1},{Neg(1, core_int)},{numRotations},{},{strengthenForward},{0},{numRotations},{weakenBackward},{Neg(1, core_int)},{n|n <- { -2..2}},{weakenForward},{0},{0},{1},{Div(occlusionSensitivity, no_zero_div(Types_BoolLidarMask_baseAngle(lidarMask)), { -2..2})|occlusionSensitivity <- { -2..2},lidarMask <- {(f_values,f_baseAngle)|f_values <- LSeq(core_boolean,2),f_baseAngle <- { -2..2}}},{sequence_toolkit_head(seq)|seq <- LSeq(Object,2)},{Types_BoolLidarMask_baseAngle(plannedLidarMask_var)|plannedLidarMask_var <- {(f_values,f_baseAngle)|f_values <- LSeq(core_boolean,2),f_baseAngle <- { -2..2}}},{n|n <- { -2..2}},{1},{0},{init|init <- Object},{Minus(n, 1, core_int)|n <- { -2..2}},{rotationAmount},{0},{Plus(n, 1, core_int)|n <- { -2..2}}}))}) 

-- VECTOR TYPES AND OPERATIONS


-- CLOCKS

-- generate sequence_functions_maxReal
sequence_functions_maxReal(a) = 0

-- generate int
nametype core_int = union({ -2..2},{calc_type_min(Union(
			{{1},{0..2},{ -2..2},{ -2..2},{0..2},{ -2..2},Object,{ -2..2},{ -2..2},{ -2..2},{ -2..2},{0..2},{0..2},{0},{sequence_toolkit_head(seq)|seq <- LSeq(Object,2)},{1},{1},{sequence_toolkit_head(seq)|seq <- LSeq(Object,2)},{Neg(1, { -2..2})},{n|n <- { -2..2}},{numRotations},{},{strengthenForward},{0},{numRotations},{weakenBackward},{Neg(1, { -2..2})},{1},{0},{init|init <- Object},{Minus(n, 1, { -2..2})|n <- { -2..2}},{n|n <- { -2..2}},{rotationAmount},{0},{weakenForward},{0},{Plus(n, 1, { -2..2})|n <- { -2..2}}}))..calc_type_max(Union({{1},{0..2},{ -2..2},{ -2..2},{0..2},{ -2..2},Object,{ -2..2},{ -2..2},{ -2..2},{ -2..2},{0..2},{0..2},{0},{sequence_toolkit_head(seq)|seq <- LSeq(Object,2)},{1},{1},{sequence_toolkit_head(seq)|seq <- LSeq(Object,2)},{Neg(1, { -2..2})},{n|n <- { -2..2}},{numRotations},{},{strengthenForward},{0},{numRotations},{weakenBackward},{Neg(1, { -2..2})},{1},{0},{init|init <- Object},{Minus(n, 1, { -2..2})|n <- { -2..2}},{n|n <- { -2..2}},{rotationAmount},{0},{weakenForward},{0},{Plus(n, 1, { -2..2})|n <- { -2..2}}}))})

-- generate const_Adaptation_Adaptation_stm_ref1_occlusionThreshold
const_Adaptation_Adaptation_stm_ref1_occlusionThreshold = 0

-- generate Div
Div(e1,e2,T) = if member(e1/e2,T) then e1/e2 else e1

-- generate sequence_functions_rotateBoolSeq
sequence_functions_rotateBoolSeq(s,n) = <>

-- generate Neg
Neg(e1,T) = if member(-e1,T) then -e1 else e1

-- generate boolean
nametype core_boolean = Bool

-- generate sequence_functions_real
sequence_functions_real(x) = 0

-- generate Mult
Mult(e1,e2,T) = if member(e1*e2,T) then e1*e2 else e1

-- generate Modulus
Modulus(e1,e2,T) = if member(e1%e2,T) then e1%e2 else e1

-- generate sequence_functions_mapSeq
sequence_functions_mapSeq(f,seq) = <>

-- generate Minus
Minus(e1,e2,T) = if member(e1-e2,T) then e1-e2 else e1

